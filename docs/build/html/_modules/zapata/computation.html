
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>zapata.computation &#8212; CMCC-Applications 0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CMCC-Applications 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">zapata.computation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for zapata.computation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">spint</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.qhull</span> <span class="k">as</span> <span class="nn">qhull</span>

<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">lin</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>

<span class="kn">import</span> <span class="nn">zapata.lib</span> <span class="k">as</span> <span class="nn">lib</span>
<span class="kn">import</span> <span class="nn">zapata.data</span> <span class="k">as</span> <span class="nn">zdat</span>
<span class="kn">import</span> <span class="nn">klus.kernels</span> <span class="k">as</span> <span class="nn">ker</span>

<span class="kn">from</span> <span class="nn">geocat.viz</span> <span class="kn">import</span> <span class="n">cmaps</span> <span class="k">as</span> <span class="n">gvcmaps</span>
<span class="kn">from</span> <span class="nn">geocat.viz</span> <span class="kn">import</span> <span class="n">util</span> <span class="k">as</span> <span class="n">gvutil</span>

<span class="kn">import</span> <span class="nn">tqdm</span> <span class="k">as</span> <span class="nn">tm</span>
<span class="kn">import</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="k">as</span> <span class="nn">tl</span>

<div class="viewcode-block" id="zonal_var"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.zonal_var">[docs]</a><span class="k">def</span> <span class="nf">zonal_var</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">season</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;LonTime&#39;</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A routine to average xarray </span>
<span class="sd">    </span>
<span class="sd">    This routine will accept xarray up to four dimensions (lat,lon,pressure, time) and return the averaged arrays with compatible dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset :      </span>
<span class="sd">        Name of the dataset, ``ERA5``, ``GPCP``       </span>
<span class="sd">    var :   </span>
<span class="sd">        Variable</span>
<span class="sd">    season :     </span>
<span class="sd">        Month or Season. Resolved from `dat_param`</span>
<span class="sd">    level : list</span>
<span class="sd">        Vertical level to extract</span>
<span class="sd">    period : list</span>
<span class="sd">        Might be None or a two element list with initial and final years</span>
<span class="sd">    option :       </span>
<span class="sd">        Control Averaging   </span>
<span class="sd">            -  None        No Averaging   </span>
<span class="sd">            - &#39;LonTime&#39;    Longitude and Time   </span>
<span class="sd">            - &#39;Lon&#39;        Longitude    </span>
<span class="sd">            - &#39;Time&#39;       Time averaging   </span>
<span class="sd">    verbose:    </span>
<span class="sd">        Tons of Output</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    average :</span>
<span class="sd">        Average. The dimension is depending on the averaging option chosen</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; zonal_var(&#39;ERA5&#39;,&#39;Z&#39;,&#39;JAN&#39;,option=&#39;LonTime&#39;)   #Longitude and Time Average for Z from ERA5</span>
<span class="sd">    &gt;&gt;&gt; zonal_var(&#39;GPCP&#39;,&#39;TPREP&#39;,&#39;DJF&#39;,option=&#39;Time&#39;,verbose=True)   # Time average </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>

        <span class="n">xx</span><span class="o">=</span><span class="n">zdat</span><span class="o">.</span><span class="n">read_xarray</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">lev</span><span class="p">,</span> <span class="n">season</span><span class="o">=</span><span class="n">season</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;LonTime&#39;</span><span class="p">:</span>
            <span class="n">xx1</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">),</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">pressure</span><span class="o">=</span><span class="p">[</span><span class="n">lev</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Time&#39;</span><span class="p">:</span>
            <span class="n">xx1</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">),</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">pressure</span><span class="o">=</span><span class="p">[</span><span class="n">lev</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Lon&#39;</span><span class="p">:</span>
            <span class="n">xx1</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">),</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">pressure</span><span class="o">=</span><span class="p">[</span><span class="n">lev</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xx1</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">pressure</span><span class="o">=</span><span class="p">[</span><span class="n">lev</span><span class="p">])</span>       

        <span class="k">if</span> <span class="n">lev</span> <span class="o">==</span> <span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">zon</span> <span class="o">=</span> <span class="n">xx1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zon</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">zon</span><span class="p">,</span> <span class="n">xx1</span><span class="p">],</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">zon</span></div>

<div class="viewcode-block" id="smooth_xarray"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.smooth_xarray">[docs]</a><span class="k">def</span> <span class="nf">smooth_xarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth xarray X with a gaussian filter . </span>

<span class="sd">    It uses a routine from scipy ndimage ( ``ndimage.gaussian_filter``). </span>
<span class="sd">    The filter is applied to all dimensions.</span>
<span class="sd">    See the doc page of ( ``ndimage.gaussian_filter``) for a full documentation.</span>
<span class="sd">    The filter can be used for periodic fields, then the correct setting of `mode` is &#39;wrap&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X :  </span>
<span class="sd">        Input Xarray    </span>
<span class="sd">    sigma:  </span>
<span class="sd">        Standard deviation for the Gaussian kernel</span>
<span class="sd">    order:  </span>
<span class="sd">        Order of the smoothing, 0 is a simple convolution</span>
<span class="sd">    mode:   </span>
<span class="sd">        *The mode parameter determines how the input array is extended when the filter overlaps a border. </span>
<span class="sd">        By passing a sequence of modes with length equal to the number of dimensions of the input array, </span>
<span class="sd">        different modes can be specified along each axis.</span>
<span class="sd">        Default value is ‘reflect’.*</span>

<span class="sd">        The valid values and their behaviors are as follows:</span>

<span class="sd">        *   ‘reflect’ (d c b a | a b c d | d c b a)</span>
<span class="sd">            The input is extended by reflecting about the edge of the last pixel.</span>
<span class="sd">        </span>
<span class="sd">        *   ‘constant’ (k k k k | a b c d | k k k k)</span>
<span class="sd">            The input is extended by filling all values beyond the edge with the same constant value, defined by the cval parameter.</span>
<span class="sd">        </span>
<span class="sd">        *   ‘nearest’ (a a a a | a b c d | d d d d)</span>
<span class="sd">            The input is extended by replicating the last pixel.</span>

<span class="sd">        *   ‘mirror’ (d c b | a b c d | c b a)</span>
<span class="sd">            The input is extended by reflecting about the center of the last pixel.</span>

<span class="sd">        *   ‘wrap’ (a b c d | a b c d | a b c d)</span>
<span class="sd">            The input is extended by wrapping around to the opposite edge.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    smooth_array:   </span>
<span class="sd">        numpy array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Smooth a X[lat,lon] array with nearest repetition in *lat* and periodicity in *lon*</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; smooth_array(X,sigma=5,order=0,mode=[&#39;nearest&#39;,&#39;wrap&#39;]) </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">lat</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">lon</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1">#there are NaN</span>
        <span class="c1"># TO DO</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    
    <span class="n">zarray</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">),</span><span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span><span class="n">lat</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span><span class="n">lon</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">zarray</span></div>

<div class="viewcode-block" id="anomaly"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.anomaly">[docs]</a><span class="k">def</span> <span class="nf">anomaly</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="n">option</span><span class="o">=</span><span class="s1">&#39;anom&#39;</span><span class="p">,</span><span class="n">freq</span><span class="o">=</span><span class="s1">&#39;month&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Anomalies according to *option*</span>

<span class="sd">    Long description here.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    var :   xarray</span>
<span class="sd">        array to compute anomalies</span>
<span class="sd">    option :</span>
<span class="sd">        Option controlling the type of anomaly calculation  </span>
<span class="sd">            =============     ==========================================================</span>
<span class="sd">            deviation         Subtract the time mean of the time series</span>
<span class="sd">            deviation_std     Subtract the time mean and normalize by standard deviation</span>
<span class="sd">            anom              Compute anomalies from monthly climatology    </span>
<span class="sd">            anomstd           Compute standardized anomalies from monthly climatology</span>
<span class="sd">            =============     ==========================================================</span>
<span class="sd">    freq :  </span>
<span class="sd">        Frequency of data   </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    anom :  xarray</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frequency</span> <span class="o">=</span> <span class="s1">&#39;time.&#39;</span> <span class="o">+</span> <span class="n">freq</span>
    <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;deviation&#39;</span><span class="p">:</span>
        <span class="n">anom</span> <span class="o">=</span> <span class="n">var</span> <span class="o">-</span> <span class="n">var</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;deviation_std&#39;</span><span class="p">:</span>
        <span class="n">anom</span> <span class="o">=</span> <span class="p">(</span><span class="n">var</span> <span class="o">-</span> <span class="n">var</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">))</span><span class="o">/</span><span class="n">var</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;anom&#39;</span><span class="p">:</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">anom</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span> <span class="o">-</span> <span class="n">clim</span>
    <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;anomstd&#39;</span><span class="p">:</span>
        <span class="n">clim</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">climstd</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">anom</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="p">,</span>
                <span class="n">var</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">frequency</span><span class="p">),</span>
                <span class="n">clim</span><span class="p">,</span>
                <span class="n">climstd</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Wrong option in `anomaly` </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">option</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">SystemExit</span>

    <span class="k">return</span> <span class="n">anom</span></div>
<div class="viewcode-block" id="Xmat"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.Xmat">[docs]</a><span class="k">class</span> <span class="nc">Xmat</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; This class creates xarrays in vector mathematical form.</span>

<span class="sd">    The xarray is stacked along `dims` dimensions</span>
<span class="sd">    with the spatial values as column vectors and time as the </span>
<span class="sd">    number of columns</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : xarray</span>
<span class="sd">        `xarray` of at leasts two dimensions</span>
<span class="sd">    dims : </span>
<span class="sd">        Dimensions to be stacked, *Default (&#39;lat&#39;,&#39;lon&#39;)*</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    A : xarray</span>
<span class="sd">        Stacked matrix of type *xarray*</span>
<span class="sd">    _ntime  :</span>
<span class="sd">        Length of time points</span>
<span class="sd">    _npoints :</span>
<span class="sd">        Length of spatial points</span>
<span class="sd">    </span>
<span class="sd">    Examples    </span>
<span class="sd">    --------    </span>
<span class="sd">    Create a stacked data matrix along the &#39;lon&#39; &#39;lat&#39;  dimension</span>

<span class="sd">    &gt;&gt;&gt; Z = Xmat(X, dims=(&#39;lat&#39;,&#39;lon&#39;))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;_ntime&#39;</span><span class="p">,</span><span class="s1">&#39;_npoints&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dims</span><span class="p">:</span>
            <span class="ne">SystemError</span><span class="p">(</span><span class="s1">&#39;Xmat needs some dimensions&#39;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Created mathematical matrix A, </span><span class="se">\n</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                stacked along dimensions </span><span class="si">{}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        
        

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Matrix vector evaluation.&#39;&#39;&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">@</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;  Printing Information &#39;&#39;&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1"> Math Data Matrix </span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; Shape of A numpy array </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span>  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
     
<div class="viewcode-block" id="Xmat.svd"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.Xmat.svd">[docs]</a>    <span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Compute SVD of Data Matrix A.</span>
<span class="sd">        </span>
<span class="sd">        The calculation is done in a way that the modes are equivalent to EOF</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N :  </span>
<span class="sd">            Number of modes desired.     </span>
<span class="sd">            If it is larger than the number of `time` levels    </span>
<span class="sd">            then it is set to the maximum</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dictionary</span>
<span class="sd">            Dictionary including </span>
<span class="sd">                =================     ==================  </span>
<span class="sd">                Pattern               EOF patterns    </span>
<span class="sd">                Singular_Values       Singular Values </span>
<span class="sd">                Coefficient           Time Coefficients   </span>
<span class="sd">                Varex                 Variance Explained  </span>
<span class="sd">                =================     ==================</span>
<span class="sd">        Examples         </span>
<span class="sd">        --------     </span>
<span class="sd">        &gt;&gt;&gt; out = Z.svd(N=10) </span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#Limit to maximum modes to time levels</span>
        <span class="n">Neig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computing </span><span class="si">{</span><span class="n">Neig</span><span class="si">}</span><span class="s1"> Modes&#39;</span><span class="p">)</span>
        <span class="c1"># Prepare arrays</span>
        <span class="n">len_modes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">Neig</span><span class="p">))</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;Modes&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">Modes</span><span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">Neig</span><span class="p">))</span>
        <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Modes&#39;</span>
        
        <span class="c1">#Compute modes</span>
        <span class="n">_u</span><span class="p">,</span><span class="n">_s</span><span class="p">,</span><span class="n">_v</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span><span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
        <span class="c1">#EOF Patterns</span>
        <span class="n">u</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_u</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">Neig</span><span class="p">]</span>
        <span class="c1">#Singular values</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">_s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Neig</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;Modes&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Neig</span><span class="p">)])</span>
        <span class="c1">#Coefficients</span>
        <span class="n">vcoeff</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">_v</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Neig</span><span class="p">,:],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Modes&#39;</span><span class="p">,</span><span class="s1">&#39;Time&#39;</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Neig</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>
        <span class="c1"># Compute variance explained</span>
        <span class="n">_varex</span> <span class="o">=</span> <span class="n">_s</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">_s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">varex</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">_varex</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Neig</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;Modes&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Neig</span><span class="p">)])</span>

        <span class="c1">#Output</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="s1">&#39;Pattern&#39;</span><span class="p">:</span><span class="n">u</span><span class="p">,</span><span class="s1">&#39;Singular_Values&#39;</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;Coefficient&#39;</span><span class="p">:</span> <span class="n">vcoeff</span><span class="p">,</span> <span class="s1">&#39;Varex&#39;</span><span class="p">:</span> <span class="n">varex</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Xmat.corr"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.Xmat.corr">[docs]</a>    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">Dim</span> <span class="o">=</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">option</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute correlation of data matrix `A` with index `y`.</span>

<span class="sd">        This method compute the correlation of the data matrix</span>
<span class="sd">        with an index of the same length of the `time` dimension of `A`</span>

<span class="sd">        The p-value returned by `corr` is a two-sided p-value.  For a</span>
<span class="sd">        given sample with correlation coefficient r, the p-value is</span>
<span class="sd">        the probability that the absolute value of the  correlation of a random sample x&#39; and y&#39; drawn from</span>
<span class="sd">        the population with zero correlation would be greater than or equal</span>
<span class="sd">        to the computed correlation. The algorithms is taken from scipy.stats.pearsonsr&#39; that can be consulted for full reference</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : xarray  </span>
<span class="sd">            Index, should have the same dimension length `time` </span>

<span class="sd">        option : str</span>
<span class="sd">            * &#39;probability&#39; _Returns the probability (p-value) that the correlation is smaller than a random sample</span>
<span class="sd">            * &#39;signicance&#39;  _Returns the significance level ( 1 - p-value)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        According to `option`   </span>

<span class="sd">        * None  </span>
<span class="sd">            corr :  Correlation array  </span>

<span class="sd">        * &#39;Probability&#39;     </span>
<span class="sd">            corr :  Correlation array   </span>
<span class="sd">            prob :  p-value array  </span>

<span class="sd">        * &#39;Significance&#39;    </span>
<span class="sd">            corr :  Correlation array   </span>
<span class="sd">            prob :  Significance array  </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Correlation of data matrix `Z` with `index`</span>

<span class="sd">        &gt;&gt;&gt; corr = Z.corr(index)</span>
<span class="sd">        &gt;&gt;&gt; corr,p = Z.corr(index,&#39;Probability&#39;)</span>
<span class="sd">        &gt;&gt;&gt; corr,s = Z.corr(index,&#39;Significance&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span><span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">Dim</span><span class="p">)</span>
        <span class="n">_corr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">Dim</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">/</span>    \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">Dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">Dim</span><span class="p">))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span>

        <span class="c1"># The p-value can be computed as</span>
        <span class="c1">#     p = 2*dist.cdf(-abs(r))</span>
        <span class="c1"># where dist is the beta distribution on [-1, 1] with shape parameters</span>
        <span class="c1"># a = b = n/2 - 1.  `special.btdtr` is the CDF for the beta distribution</span>
        <span class="c1"># on [0, 1].  To use it, we make the transformation  x = (r + 1)/2; the</span>
        <span class="c1"># shape parameters do not change.  Then -abs(r) used in `cdf(-abs(r))`</span>
        <span class="c1"># becomes x = (-abs(r) + 1)/2 = 0.5*(1 - abs(r)).  </span>

        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Probability&#39;</span><span class="p">:</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Avoid small numerical errors in the correlation</span>
            <span class="n">_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">_corr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">btdtr</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_p</span><span class="p">)))</span>
        
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">prob</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">return</span> <span class="n">_corr</span> <span class="p">,</span> <span class="n">prob</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Significance&#39;</span><span class="p">:</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Avoid small numerical errors in the correlation</span>
            <span class="n">_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">_corr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">btdtr</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_p</span><span class="p">)))</span>
        
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">prob</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">p</span>
            <span class="k">return</span> <span class="n">_corr</span> <span class="p">,</span> <span class="n">prob</span>
        <span class="k">else</span><span class="p">:</span>
        <span class="c1"># return only correlation</span>
            <span class="k">return</span> <span class="n">_corr</span></div>
    
<div class="viewcode-block" id="Xmat.cov"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.Xmat.cov">[docs]</a>    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">Dim</span> <span class="o">=</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute covariance of data matrix `A` with `index`.</span>

<span class="sd">        This method compute the correlation of the data matrix</span>
<span class="sd">        with an index of the same length of the `time` dimension of `A`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Covariance of data matrix `Z` with `index`</span>

<span class="sd">        &gt;&gt;&gt; cov = Z.cov(index)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span><span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">Dim</span><span class="p">))</span>
        <span class="n">_cov</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">Dim</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_ntime</span>
        <span class="k">return</span> <span class="n">_cov</span></div>

<div class="viewcode-block" id="Xmat.anom"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.Xmat.anom">[docs]</a>    <span class="k">def</span> <span class="nf">anom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Creates anomalies.</span>

<span class="sd">        This is using the function `anomaly` from `zapata.computation` </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">anomaly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> </div></div>
<div class="viewcode-block" id="feature_to_input"><a class="viewcode-back" href="../../zapata.computation.html#zapata.computation.feature_to_input">[docs]</a><span class="k">def</span> <span class="nf">feature_to_input</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">num</span><span class="p">,</span><span class="n">PsiX</span><span class="p">,</span><span class="n">Proj</span><span class="p">,</span><span class="n">icstart</span><span class="o">=</span><span class="mf">0.15</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Transform from Feature space to input space.</span>

<span class="sd">    It computes an approximate back-image for the Gaussian kernels and</span>
<span class="sd">    and exact backimage for kernels based on scalar product whose nonlinear</span>
<span class="sd">    map can be inverted.</span>

<span class="sd">    Still working on.</span>

<span class="sd">    Parameters  </span>
<span class="sd">    ----------  </span>

<span class="sd">        k :    Kernel    </span>
<span class="sd">            Kernel to be used   </span>
<span class="sd">        num :   </span>
<span class="sd">            Number of RKHS vectors to transform </span>
<span class="sd">        PsiX :  array (npoints,ntime)</span>
<span class="sd">            Original data defininf the kernel   </span>
<span class="sd">        Proj :  </span>
<span class="sd">            Projction coefficients on Feature Space</span>
<span class="sd">        icstart :   </span>
<span class="sd">            Starting Value for iteration    </span>
<span class="sd">    Returns</span>
<span class="sd">    ------- </span>
<span class="sd">        back_image : array(npoints, num)    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nx</span><span class="p">,</span><span class="n">nt</span><span class="o">=</span><span class="n">PsiX</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Vector is too large for back-image&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="n">name</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Gaussian&#39;</span><span class="p">:</span>
       
        <span class="c1"># Eigenfunctions in the input space</span>
        
        <span class="c1">#Expand the eigenfunction in the data space</span>
        <span class="c1"># Use iteration by Scholkopf 1999</span>
        <span class="n">xold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">PsiX</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">DataEig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span><span class="n">num</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>    
            <span class="n">xold</span><span class="p">[:]</span><span class="o">=</span><span class="n">icstart</span>
            <span class="n">vec</span><span class="o">=</span><span class="n">Proj</span><span class="p">[:,</span><span class="n">it</span><span class="p">]</span>
            <span class="n">conv</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">kount</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">while</span> <span class="n">conv</span> <span class="o">&gt;</span> <span class="mf">1.e-5</span><span class="p">:</span>
                <span class="n">nom</span><span class="o">=</span><span class="mf">0.0</span>
                <span class="n">den</span><span class="o">=</span><span class="mf">0.0</span>        
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                    <span class="n">pr</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">k</span><span class="p">(</span><span class="n">xold</span><span class="p">,</span><span class="n">PsiX</span><span class="p">[:,</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">nom</span><span class="o">=</span><span class="n">pr</span><span class="o">*</span><span class="n">PsiX</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nom</span>
                    <span class="n">den</span><span class="o">=</span><span class="n">pr</span> <span class="o">+</span> <span class="n">den</span>
                <span class="n">xnew</span><span class="o">=</span><span class="n">nom</span><span class="o">/</span><span class="n">den</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xnew</span> <span class="o">-</span> <span class="n">xold</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1">#print( &#39;  Convergence/j  &#39;, conv,it)</span>
                <span class="n">xold</span><span class="o">=</span><span class="n">xnew</span>  
                <span class="n">kount</span> <span class="o">=</span> <span class="n">kount</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">kount</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;  Not Converged -- Convergence/j  &#39;</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span><span class="n">it</span><span class="p">,</span><span class="n">kount</span><span class="p">,</span><span class="n">den</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">DataEig</span><span class="p">[:,</span><span class="n">it</span><span class="p">]</span><span class="o">=</span> <span class="n">xnew</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;  Convergence/num  &#39;</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Polynomial&#39;</span><span class="p">:</span>   
        <span class="c1">#Exact method</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Kernel  &#39;</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reconstructing Projection as (nx,nt) &#39;</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span><span class="n">nx</span><span class="p">,</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">xold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">PsiX</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">DataEig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span><span class="n">num</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">G00</span> <span class="o">=</span> <span class="n">ker</span><span class="o">.</span><span class="n">gramian2</span><span class="p">(</span><span class="n">PsiX</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Vector Number  ---&gt; &#39;</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">G00</span> <span class="o">@</span> <span class="n">Proj</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">acc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">G00</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">Proj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
            <span class="c1">#for i in range(nx):</span>
            <span class="c1">#    sum=0.0</span>
             <span class="c1">#   for j in range(nt):</span>
             <span class="c1">#       sum = Proj[j,it]* k(PsiX[:,j],I[:,i])+sum</span>
            <span class="n">DataEig</span><span class="p">[:,</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc</span><span class="o">-</span><span class="n">k</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in Reconstruction&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DataEig</span>   </div>
      
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/zap.png" alt="Logo"/>
            </a></p>
<h3><a href="../../index.html">Table of Contents</a></h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Zapata</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CMCC-Applications 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">zapata.computation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, AN.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.0.
    </div>
  </body>
</html>